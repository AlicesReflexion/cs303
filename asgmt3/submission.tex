\documentclass[12pt]{article}
\usepackage[left=2cm, right=2cm, top=1cm, bottom=2cm]{geometry}
\title{CS303 Data Structures Assignment \#3\\
\large attachments and source available at https://github.com/alexskc/cs303}
\author{Aleksander Charatonik}
\begin{document}

\maketitle

\section{}
A \texttt{const\_iterator} is useful in preventing modifying the referenced value. It's simply about const correctness, and informs what the programmer should be able to do. \texttt{iterator}, by contrast, has read-write access, and is useful in scenarios where that is necessary.

\section{}
\subsection*{a}
An \texttt{iterator}. Regardless of whether you have an array-based structure, or a linked-list structure, you need to be able to change either the value of the next item, or the pointer to the next item.
\subsection*{b}
\texttt{iterator} as well. You are modifying data, so you cannot be read-only.
\subsection*{c}
For this one, a \texttt{cost\_iterator} will suffice. We are not changing any data.
\subsection*{d}
\texttt{iterator} as well. We can avoid changing the element pointed to if we're using a linked-list structure, but we still need to change the element before it to point to the new item. And of course, in an array-based structure, we're going to be moving elements around in the array to make space for the new element.

\section{}
See attached \texttt{reverser.cpp}

\section{}
\begin{tabular}{| l | l | l |}
  \hline
  \textbf{Expression} & \textbf{Action} & \textbf{Stack} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
    \(\uparrow\)
  \end{tabular} & Push 10 & 
  \begin{tabular}{|c|}
    \hline
    10\\ \hline
  \end{tabular} \\ \hline
    \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       & \(\uparrow\)\\
  \end{tabular} & Push 2 & 
  \begin{tabular}{|c|}
    \hline
    2\\ \hline
    10\\ \hline
  \end{tabular} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       &   & \(\uparrow\)\\
  \end{tabular} & Eval * & 
  \begin{tabular}{|c|}
    \hline
    20\\ \hline
  \end{tabular} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       &   &   & \(\uparrow\)\\
  \end{tabular} & Push 5 & 
  \begin{tabular}{|c|}
    \hline
    5\\ \hline
    20\\ \hline
  \end{tabular} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       &   &   &   & \(\uparrow\)\\
  \end{tabular} & Eval / & 
  \begin{tabular}{|c|}
    \hline
    4\\ \hline
  \end{tabular} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       &   &   &   &   & \(\uparrow\)\\
  \end{tabular} & Push 6 & 
  \begin{tabular}{|c|}
    \hline
    6\\ \hline
    4\\ \hline
  \end{tabular} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       &   &   &   &   &   & \(\uparrow\)\\
  \end{tabular} & Push 2 & 
  \begin{tabular}{|c|}
    \hline
    2\\ \hline
    6\\ \hline
    4\\ \hline
  \end{tabular} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       &   &   &   &   &   &   & \(\uparrow\)\\
  \end{tabular} & Push 5 & 
  \begin{tabular}{|c|}
    \hline
    5\\ \hline
    2\\ \hline
    6\\ \hline
    4\\ \hline
  \end{tabular} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       &   &   &   &   &   &   &   & \(\uparrow\)\\
  \end{tabular} & Eval * & 
  \begin{tabular}{|c|}
    \hline
    10\\ \hline
    6\\ \hline
    4\\ \hline
  \end{tabular} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       &   &   &   &   &   &   &   &   & \(\uparrow\)\\ 
  \end{tabular} & Eval + & 
  \begin{tabular}{|c|}
    \hline
    16\\ \hline
    4\\ \hline
  \end{tabular} \\ \hline
  \begin{tabular}{c c c c c c c c c c c}
    10 & 2 & * & 5 & / & 6 & 2 & 5 & * & + & -\\
       &   &   &   &   &   &   &   &   &   & \(\uparrow\)\\
  \end{tabular} & Eval - & 
  \begin{tabular}{|c|}
    \hline
    -12\\ \hline
  \end{tabular} \\ \hline
\end{tabular}

\section{}
y - 7 * 35 + 4 / 6 - 10\\
Operator Stack:\\
\begin{tabular}{|c|}
  \hline
  \\ \hline
\end{tabular}
\begin{tabular}{|c|}
  \hline
  -\\ \hline
\end{tabular}
\begin{tabular}{|c|}
  \hline
  *\\ \hline
  -\\ \hline
\end{tabular}
\begin{tabular}{|c|}
  \hline
  +\\ \hline
\end{tabular}
\begin{tabular}{|c|}
  \hline
  /\\ \hline
  +\\ \hline
\end{tabular}
\begin{tabular}{|c|}
  \hline
  -\\ \hline
  +\\ \hline
\end{tabular}\\
\\
\\
\\
( x + 15 ) * ( 3 * ( 4 - ( 5 + 7 / 2 ) ) )\\
Operator Stack:\\
\begin{tabular}{|c|}
  \hline
  \\ \hline
\end{tabular}
\section{}
  We should be able to simply modify the OPERATORS string to also include \texttt{\^}. We should note that C++ doesn't have a \texttt{\^} operator, instead we use the \texttt{pow()} function in \texttt{cmath}, however our program doesn't need to concern itself with that.
\section{}
If order doesn't matter, and the original queue doesn't matter, we can simply always read the front, print it, and then pop it. This would display all the elements, but in a backwards order, and the original queue would be gone.\\
\\
If we want to display in the original order, and preserve the original queue, then what we should do is: \\
1. Read the front element\\
2. Push it to the back\\
3. Pop it from the front\\
4. Repeat until the queue is backwards\\
\\
5. Read the front element\\
6. Print it out\\
7. Push it to the back\\
8. Pop it from the front\\
9. Repeat until the queue retains its original order.
\section{}
\begin{verbatim}
void move_to_rear(queue<T> queue) {
  queue.push(queue.front())
  queue.pop();
  }
\end{verbatim}
\end{document}
